{"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/advanced":{"title":"Advanced","data":{"":"This is the index page for the Advanced folder!"}},"/front-end":{"title":"Front-end development overview","data":{"":"This part is about web development. Here you will find instructions on how to set up your projects, best practices, and examples of how to use third-party libraries to solve typical tasks.\nThe matters of UI testing are also considered.This particular section contains an overview of a front-end project setup"}},"/front-end/css":{"title":"Css tips and hints","data":{"":"This chapter contains hints on set up and maintain application-wide style theme","in-this-chapter#In this chapter":":::{tableofcontents}\n:::"}},"/front-end/css/stylesheets":{"title":"Stylesheets","data":{"":":::{note}\nHere is going to be some tips on how to name, place & write styles in a separate files\n:::"}},"/front-end/css/tailwind-css":{"title":"Tailwind CSS","data":{"":":::{note}\nHere is going to be placed info about tailwind-css philosophy & usage\n:::"}},"/front-end/css/theme":{"title":"Application theme","data":{"":"Here is going to be description on how to set up application's theme based on theme.js concept with tailwind & interactions with component libraries\nmodule.exports = {\n  theme: {\n    ...\n  },\n  plugins: [\n    function({ addBase, theme }) {\n      function extractColorVars(colorObj, colorGroup = '') {\n        return Object.keys(colorObj).reduce((vars, colorKey) => {\n          const value = colorObj[colorKey];\n          const newVars =\n            typeof value === 'string'\n              ? { [`--color${colorGroup}-${colorKey}`]: value }\n              : extractColorVars(value, `-${colorKey}`);\n          return { ...vars, ...newVars };\n        }, {});\n      }\n      addBase({\n        ':root': extractColorVars(theme('colors')),\n      });\n    },\n  ],\n};"}},"/front-end/data/easy-peasy/best-practices":{"title":"Easy peasy best practices","data":{}},"/front-end/data/easy-peasy/data-storing":{"title":"Storing data","data":{}},"/front-end/data/easy-peasy":{"title":"Easy peasy","data":{}},"/front-end/data":{"title":"Hints to working with a data","data":{"":"This section covers the following topics:\nfetching and storing data\nreact-query fetching\nmutations & optimistic updates\neasy-peasy: store structure & usage","in-this-section#In this section":""}},"/front-end/data/react-query/data-fetching":{"title":"Fetching server data","data":{}},"/front-end/data/react-query":{"title":"React query","data":{}},"/front-end/data/react-query/optimistic-updates":{"title":"Optimistic updates","data":{}},"/front-end/forms/custom-components":{"title":"Custom form components","data":{"":":::{note}\nThere's nothing here yet, but surely something cool will appear 😉\n:::"}},"/front-end/forms":{"title":"Introduction to working with forms","data":{"":"This chapter contains instructions for creating user input forms based on the react-hook-forms library.","in-this-chapter#In this chapter":":::{tableofcontents}\n:::"}},"/front-end/forms/validation":{"title":"Validation with yup","data":{"":":::{note}\nThere's nothing here yet, but surely something cool will appear 😉\n:::"}},"/front-end/forms/writing-forms":{"title":"Writing forms","data":{"":":::{note}\nThere's nothing here yet, but surely something cool will appear 😉\n:::"}},"/front-end/links":{"title":"Useful links","data":{"":":::{note}\nThere's nothing here yet, but surely something cool will appear 😉\n:::"}},"/front-end/overview/best-practices":{"title":"Project best practices","data":{"100-lines-rule#100 lines rule":":::{epigraph}\nThe first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that. Functions should not be 100 lines long. Functions should hardly ever be 20 lines long.-- Bob Martin, Clean Code\n:::This can be fully applied to the components of the react."}},"/front-end/overview/folder-structure":{"title":"Folder structure","data":{"":"This chapter will cover the best practices in structuring files and folders of the project.\nWhile this is under construction please check this useful article Delightful React File/Directory Structure"}},"/front-end/overview/project-setup":{"title":"Project setup","data":{"yarn-setup#yarn setup":"To initialise yarn 3 on your local machine follow these steps:\nDelete the web solution folder and clone it from git.\nOne by one, execute the following commands:\nyarn\nyarn build\nyarn dlx @yarnpkg/sdks vscode\nIn the VS Code file explorer navigate to any typescript file e.g. front/src/App.tsx\nThe message box \"This workspace contains a typescript version...\" should appear. Click the \"Allow\" button to configure typescript type checking.\n ../../../assets/vs-code-yarn-typescript-setup.png","rider-setup#Rider setup":"run scripts\nformat code with prettier (https://www.jetbrains.com/help/rider/Prettier.html)\nset up linting (https://www.jetbrains.com/help/rider/eslint.html#ws_eslint_configure_highlighting)","vs-code-setup#VS Code setup":"run scripts\ninstall prettier plugin\ninstall eslint\ncustom settings","eslint--prettier#Eslint & Prettier":"For styling & formatting of any aspect of front-end code we use ESLint with mostly airbnb presets & Prettier.In typescript files ESLint errors & warnings will be highlighted if using VS Code extension ESLint extensionTo check eslint in all files run command\nyarn build\nOr for deeper but slower test use\nyarn test:ci\nLots of useful eslint rules are turned off because of amount of fixes needed to use such rules. So to increase the code quality you can switch on some of rules listed in toBeFixed section in the .eslintrc file and fix lint errors.","project-structure--imports#Project structure & imports":"use index.ts for cleaner imports from @components/hooks etc.\nplace common components in @components\ndo not use Helpers or any other common React files. Only pure js/ts service functions should be placed in various utils.ts files","component-file-formatting#Component file formatting":"This is the preferred code layout for react component file:\nimport <es modules imports>;\nconst Component: FC<TProps> = () => {\n  // Code of component no more than 100 lines long\n}\nfunction mapState(state: TStoreState) {\n  // Pure functions used exclusively by the component\n}\ntype TProps = {\n  // Type declaration for component properties\n}","place-all-additional-code-as-pure-functions-under-component-or-in-separate-file#Place all additional code as pure functions under component or in separate file":"// TODO: add example","naming-conventions#Naming conventions":""}},"/front-end/plugins":{"title":"IDE plugins","data":{"eslint#ESlint":"Eslint for rider:\nhttps://www.jetbrains.com/help/rider/eslint.html\nprettier for rider","path-intellisense--alias-config-in-settings#path intellisense + alias config in settings":"","todo#todo":"","spellcheck#spellcheck":""}},"/front-end/react/best-practices":{"title":"React best practices","data":{"meaningless-function-names#Meaningless function names":"❌ Not: name function like check, perform, process\nFunction does not check status, but validates selectedPropertiesData\nUntil you read function's code you cannot guess if true means valid or not\nfunction checkStatus() {\n  return (isEmpty(selectedPropertiesData) || !selectedPropertiesData.every((prop: any) => prop.status === selectedPropertiesData[0].status);)\n}\n✅ Do: prefer to name functions like getSomethingFunction name is self explanatory\nfunction getIsReadyForStatusUpdate() {\n  // Allow to update status if there are selected properties\n  if (!isEmpty(selectedPropertiesData)) return false;\n  // And all selected properties are in the same status\n  return selectedPropertiesData.every((prop: any) => prop.status === selectedPropertiesData[0].status);\n}","using-locationpathname-based-logic#Using location.pathname based logic":"❌ Not: use location.pathname in any conditions\n    switch (pathname) {\n        case '/properties':\n            tabs = ListingSearchButtons;\n            searchBar = searchComp;\n            break;\n        case '/admin':\n            tabs = null;\n            break;\n        default:\n            if (location.includes(`${listingSearch}/`) && location.length > 12) {\n                tabs = null;\n            }\n            break;\n    }\n✅ Do: prefer to use routingFunction name is self explanatory\n:::{code-block} jsx\n<Route path=\"/properties/\" element={} />\n<Route path=\"/admin/\" element={} />\n<Route path=\"/\" element={} />\n:::","using-lots-of-usestate#Using lots of useState":"Combine to single state for better performance","using-usestate-for-reference-types#Using useState for reference types":"shallow copy with useState","shallow-copy-for-easy-peasy#shallow copy for easy-peasy":"","named-export--memo#named export + memo":"","avoid-props-in-favor-of-direct-store-access#avoid props in favor of direct store access":"","do-not-use-functions-to-generate-html-prefer-child-components#Do not use functions to generate html, prefer child components":"❌ Not: use getContent, buttonsFactory or similar\nconst Component: FC = () => {\n  const getTooltipContent = (options: string[]) => {\n    return options.map((option) => {\n      return;\n    });\n  };\n  const createTooltipContentItem = (title: string): ReactNode => (\n    <div className={`text-base flex nowrap justify-between items-center`}>\n      {title}\n    </div>\n  );\n  return <div>{getTooltipContent([\"one\", \"two\", \"three\"])}</div>;\n};\n✅ Do: prefer create of a separate components\ntype TProps = {\n  title: string;\n};\nconst TooltipContentItem: FC<TProps> = ({ title }) => (\n  <div className={`text-base flex nowrap justify-between items-center`}>\n    {title}\n  </div>\n);\nconst Component: FC = () => (\n  <div>\n    {[\"one\", \"two\", \"three\"].map((option) => (\n      <TooltipContentItem option={option} />\n    ))}\n  </div>\n);","remove-all-store-stateactions-mappings-to-mapstatemapactions#Remove all store state/actions mappings to mapState/mapActions":"// TODO: add shallowCopy to mappings❌ Not:\nconst Component: FC = () => {\n  const userName = useStore((state: TStoreState) => authentication.userName);\n  const price = useStore((state: TStoreState) => offer.price);\n  ...\n}\n✅ Do:\nconst Component: FC = () => {\n  const { userName, price } = useStore(mapState);\n  ...\n}\nfunction mapState(state: TStoreState) {\n  return {\n    userName: state.authentication.userName,\n    price: state.offer.price\n  }\n}"}},"/front-end/react":{"title":"ReactJs tips and hints","data":{"in-this-section#In this section":":::{tableofcontents}\n:::"}},"/front-end/testing/coverage":{"title":"Collecting coverage","data":{"":"Code coverage tells you which code has been executed during a test and how many times. Targeting for 100% code coverage is often a mistake as it will take a lot of time (to get there and to maintain), and it can lead to problematic testing practices. Having a high percentage of coverage does not necessarily increase the quality, bugs will always pop up.We use code coverage as a tool, as a last check to verify that the code is ready. It can discover edge cases we haven't thought of and it can make poorly written code visible. Coverage analysis is optional, but useful.:::{important}\nWe will aim for 70% line coverage for all files that have changed in the current feature branch compared to dev.\n::::::{note}\nSnapshots contribute significantly to UI test coverage. Create at least one snapshot for each storybook, and you will provide a significant portion of the required coverage.\n:::","how-to-read-coverage-report#How to read coverage report":"Let's put this in to practice. As a test we're going to take a look at the code coverage of a fizz buzz function. FizzBuzz is a small function that, depending on the input will return a different output. If the input value:\nis divisible by three it returns Fizz, e.g. 6\nis divisible by five, it returns Buzz, e.g. 20\nis divisible both three and five it returns FizzBuzz, e.g. 15\notherwise it returns the input value, e.g. 7\nA possible solution of the fizz buzz function looks a follows:\n:::{code-block} typescript\nfunction fizzBuzz(value) {\nlet output = ''\nif (value % 3 == 0) output += 'Fizz'\nif (value % 5 == 0) output += 'Buss'\nreturn output || value.toString()\n}\n:::As our first test we're covering the easiest case, an input that is not divisible and simply returns the input value:\n:::{code-block} typescript\ndescribe('Returns the input', () => {\nit('if it is not divisible by three or five', () => {\nexpect(fizzbuzz(7)).toBe('7')\n})\n})\n:::If we now generate the code coverage we see a coverage report directly in the CLI::::{thumbnail} ../../../assets/jest-coverage-1.png\n:title: An image that shows the coverage in the CLI\n:show_caption: 'True'\n:::A coverage report that can be opened in the browser by running a command\n:::{code-block} console\nhttp-server ./coverage/lcov-report\n:::Or just by opening the ./coverage/lcov-report/index.html:::{thumbnail} ../../../assets/jest-coverage-2.png\n:title: An image that shows the coverage in the browser\n:show_caption: 'True'\n:::It's even possible to click on the files to have a view to see which lines are covered, and which are not::::{thumbnail} ../../../assets/jest-coverage-3.png\n:title: An image that shows the coverage in the browser for a specific file\n:show_caption: 'True'\n:::In all of the screenshots above, you have four different percentages to look at:\nStatement coverage – Has each statement in the program been executed?\nBranch coverage – Has each branch (also called DD-path) of each control structure (such as in if and case statements) been executed? For example, given an if statement, have both the true and false branches been executed? Notice that this one is a subset of Edge coverage.\nFunction coverage – Has each function (or subroutine) in the program been called?\nLine coverage has each executable line in the source file been executed?"}},"/front-end/testing":{"title":"Introduction to front-end testing","data":{"":"This chapter contains a detailed breakdown of techniques for creating UI tests and their effective coverage of the code base.","what-to-test-and-why#What to test and why":"Lets test UI components behavior with integration tests by using storybook & jest.\nLets test UI layout with jest snapshots automated by storybook storyshots addon.Read a good article about what & why to test on UI K.Odds \"Write tests. Not too many. Mostly integration.\"More useful articles and links you can find here","this-is-how-we-test#This is how we test":"Create storybook for testable component\nMock api, state, router, components\nWrite stories\nTest layout with snapshots\nTest stories with Jest\nMeasure tests coverage\nImplement testing best practices"}},"/front-end/testing/links":{"title":"Useful links","data":{"kent-c-odds#Kent C. Odds":"https://kentcdodds.com/blog/common-mistakes-with-react-testing-libraryhttps://kentcdodds.com/blog/testing-implementation-details","storybooks--component-design#Storybooks & component design":"https://storybook.js.org/docs/react/get-started/introductionhttps://www.componentdriven.org/https://www.designbetter.co/design-systems-handbook/introducing-design-systems"}},"/front-end/testing/writing-tests":{"title":"Writing tests with Jest","data":{"":":::{important}\nTry to transfer as much testing as possible to snapshots. There is no need to manually create jest tests on hundreds of lines to make sure that after loading the data the component will display all the required fields. Such tests are replaced by a single snapshot that includes everything needed.\n:::We only need jest tests if we want to test the component dynamically. Set the initial conditions, interact with the component, find out that the necessary changes were made after the interaction.To achieve this we will use Jest, React Testing Library and storybook interactions.Let's describe the typical functional integration test using the familiar EmployeeProfile component, the stories for which we created in the last chapter.Let's assume that after the user with admin privileges pressed the \"Edit\" button, a modal window for editing the profile is displayed, with an input with the name \"position\" and a \"Save\" button.\nLet's write a test to check that after changing the \"position\" value in the modal and pressing the \"Save\" button, the EmployeeProfile component will immediately start displaying the new position value.","1-preparing-a-story-with-input-conditions-for-the-test#1. Preparing a story with input conditions for the test":":::{important}\nTry to transfer as much logic as possible from the tests to the stories, because the latter are much easier to debug visually.\n:::To prepare the component for testing, let's create a story in which the data we need is passed to the component. In our case this is the TUserRole.ADMIN user role.\nLet's also prepare the interaction with the play history function, which will wait for the \"Edit\" button to appear and press this button to call the modal window. This part is described in the chapter Writing stories.","2-creating-a-test-with-a-story-rendered#2. Creating a test with a story rendered":"Now create our test by placing it next to the component under test\n:::{code-block}\n:emphasize-lines: 7\nfront/\n┗ @components/\n┣ EmployeeProfile/\n┃ ┣ index.ts\n┃ ┣ employee-profile.tsx\n┃ ┣ employee-profile.stories.tsx\n┃ ┗ employee-profile.spec.tsx\n┣ ...\n:::Storybook allows us to render the story as a test component.\nIn doing so, we can read its parameters, pass properties to it, and call its play function to initiate a pre-prepared interaction.:::{code-block} typescript\n:caption: Interaction test around component's story calling play function to interact with underlying component\n:linenos:\nimport * as stories from './employee-profile.stories';\nconst { Admin } = composeStories(stories);describe('Should match snapshot', () => {\ntest('with edit modal opened', async () => {\n// render component's story\nconst { container, baseElement } = render();\n    // perform interaction with testing component\n    await act(() => Admin.play({ canvasElement: container }));\n    // use React Testing Library to access visible DOM elements\n    await screen.findByText('Edit modal title');\n    // some test logic to be here\n});\n});\n:::","3-write-test-logic#3. Write test logic":"Now using all the power of React Testing Library we can find in our modal window input \"position\", enter data, close the window by clicking \"Save\" button and make sure that the component displays the new value of the position.:::{code-block} typescript\n:caption: Interaction test around component's story calling play function to interact with underlying component\n:linenos:import {render, fireEvent} from '@testing-library/react'\nimport * as stories from './employee-profile.stories';\nconst { Admin } = composeStories(stories);describe('Should match snapshot', () => {\ntest('with edit modal opened', async () => {\n// render component's story\nconst { container, baseElement, getByLabelText } = render();\n    // perform interaction with testing component\n    act(() => await Admin.play({ canvasElement: container }));\n    // use React Testing Library to access visible DOM elements\n    await screen.findByText('Edit modal title');\n    // find the \"position\" input in the modal window\n    const input = getByLabelText('Position');\n    fireEvent.change(input, {target: {value: 'Senior Fullstack Developer'}})\n    \n    // find the \"save\" button in the modal window \n    const saveButton = getByText('Save');\n    \n    // and click it\n    act(() => {\n        await userEvent.click(saveButton);\n    });\n    // check that modal window disappeared\n    await waitFor(() => {\n        expect(queryByText('Edit modal title')).not.toBeInTheDocument()\n    })\n    // and finally check that the new value displayed\n    expect(screen.getByText('Senior Fullstack Developer')).toBeInTheDocument();\n});\n});\n:::","4-check-and-debug-the-test#4. Check and debug the test":"To quickly run test separately specify the test filename calling test script:::{code-block} console\nyarn test employee-profile.spec.tsx\n::::::{seealso}\nReact Testing Library debugging\nJest troubleshooting\n:::"}},"/front-end/typescript/best-practices":{"title":"Typescript best practices","data":{"enums#Enums":"Enums are typescript types, named with a capital T without a plural❌ Not:\nexport type MyStatuses = {\n  NEW = 'New',\n  ASSIGNED = 'Assigned',\n  ...\n}\n✅ Do:\nexport type TStatus = {\n  NEW = 'New',\n  ASSIGNED = 'Assigned',\n  ...\n}","meaningless-function-names#Meaningless function names":"❌ Not: name function like check, perform, process\nFunction does not check status, but validates selectedPropertiesData\nUntil you read function's code you cannot guess if true means valid or not\nfunction checkStatus() {\n  return (isEmpty(selectedPropertiesData) || !selectedPropertiesData.every((prop: any) => prop.status === selectedPropertiesData[0].status);)\n}\n✅ Do: prefer to name functions like getSomethingFunction name is self explanatory\nfunction getIsReadyForStatusUpdate() {\n  // Allow to update status if there are selected properties\n  if (!isEmpty(selectedPropertiesData)) return false;\n  // And all selected properties are in the same status\n  return selectedPropertiesData.every((prop: any) => prop.status === selectedPropertiesData[0].status);\n}"}},"/front-end/typescript":{"title":"Typescript tips and hints","data":{"in-this-section#In this section":":::{tableofcontents}\n:::"}},"/":{"title":"Introduction","data":{"":"Welcome to Nextra! This is a basic docs template. You can use it as a starting point for your own project :)","what-is-nextra#What is Nextra?":"A simple, powerful and flexible site generation framework with everything you love from Next.js.","documentation#Documentation":"The documentation is available at https://nextra.site."}},"/another":{"title":"Another Page","data":{"":"let a = 1;\nconsole.log(a);","component#Component":"","external-component#External Component":""}},"/front-end/testing/best-practices":{"title":"Best practices","data":{"":"This section contains useful tips for applying the testing techniques described in this chapter.","storybook#Storybook":"","use-typed-stories#Use typed stories":":::{code-block} typescript\n:linenos:\n:caption: \"✅ Inherit default export & each story from Meta type from @storybook/react\"\nimport { Meta } from '@storybook/react';export default {\ntitle: 'Pages/ActiveProperties/ActivePropertiesFilters',\ncomponent: ActivePropertiesFilters,\ndecorators: [\nwithApi([\nApiMock['/api/acquire/companytitles'],\nApiMock['/api/acquire/users'],\n]),\n],\n} as Meta;export const ActivePropertiesDefault: Meta = {\nargs: { ...defaultArgs },\n};\n:::Using typed stories will allow you to use the full power of the Typescript inside the Storybook. In particular, it will help you find typos.","tests#Tests":":::{note}\nFirst of all please check this great guide from Kent C. Odds Common mistakes with React Testing Library\n:::","prefer-using-methods-from-react-testing-library-not-from-jest#Prefer using methods from React Testing Library not from Jest":":::{code-block} typescript\n:caption: \"❌ Not: use jest methods for direct access DOM nodes\"\nconst myElement = screen.getByTestId('my-element');\nconst [anchorTag] = myElement.getElementsByTagName('a');\nexpect(anchorTag?.getAttribute('href')).toBe('https://www.expected.com');\n::::::{code-block} typescript\n:caption: \"✅ Prefer to use methods from React Testing Library\"\nconst anchorTag = screen.getByText('Expected text');\nexpect(myElement).toBeInTheDocument();\n:::The Testing Library offers more advanced methods for finding elements that are resistant to changes in markup. Check this ESLint rule","avoid-querying-of-testing-elements-by-data-testid-or-any-other-attributes-invisible-to-user#Avoid querying of testing elements by data-testid or any other attributes invisible to user":":::{code-block} typescript\n:caption: \"❌ Not: use data-testid attributes to find an element\"\nconst myElement = screen.getByTestId('my-element');\nexpect(myElement).toHaveTextContent('Expected text');\n::::::{code-block} typescript\n:caption: \"✅ Prefer to find by displayed text or label\"\nconst myElement = screen.getByText('Expected text');\nexpect(myElement).toBeInTheDocument();\n:::Based on the Guiding Principles, your test should resemble how users interact with your code (component, page, etc.) as much as possible.","for-asynchronously-loaded-items-use-the-async-methods-from-testing-library#For asynchronously loaded items, use the async methods from Testing Library":":::{code-block} typescript\n:caption: \"❌ Not: use synchronous methods when dealing with data loaded asynchronously\"\nconst myAsyncElement = screen.getByText('Expected text');\nexpect(myAsyncElement).toBeInTheDocument();\n::::::{code-block} typescript\n:caption: \"✅ Await asynchronous findBy* methods to avoid the races between test assert and data loading\"\nconst myAsyncElement = await screen.findByText('Expected text');\nexpect(myAsyncElement).toBeInTheDocument();\n:::Suppose that the element \"Expected text\" appears on the screen with a delay after loading data from the mocked REST Api. Even a small delay in this case will be enough for the synchronous test to start behaving unpredictably - sometimes to find the element and sometimes not."}},"/front-end/testing/mocks":{"title":"Mocks","data":{"":"Mock - a way to replace the real dependencies of a component with test dependencies with controllable results.Storybook uses decorators for this purpose. Let's look at the main types of mock decorators:::{seealso}\nLearn more about decorators at storybook section\n:::","api-mocks#API mocks":"For HTTP requests, mocks are applied using the msw library in the msw-storybook-addon variant.\nMsw intercepts REST and GraphQL requests at the serviceWorker level, thus being completely independent of specific HTTP service implementations.Here are the typical steps to mock a REST request.","1-collect-requests-to-be-mocked#1. Collect requests to be mocked":"Run storybook\nOpen browser's developer tools & check console output\nCheck warnings \"Warning: captured a request without a matching request handler\"\nCollect unhandled requests to api","2-check-if-there-is-already-mocked-data-prepared#2. Check if there is already mocked data prepared":"This is an example of the api mocks folder structure\nfront/\n┗ mocks/\n  ┣ Api/\n  ┃ ┣ Facilgo/\n  ┃ ┃ ┣ getWorkOrders.response.mock.ts\n  ┃ ┃ ┗ index.ts\n  ┃ ┣ Resident/\n  ┃ ┃ ┗ index.ts\n  ┃ ┣ Scheduler/\n  ┃ ┃ ┣ getTimeSlots.response.mock.ts\n  ┃ ┃ ┗ index.ts\n  ┃ ┣ Ticket/\n  ┃ ┃ ┗ index.ts\n  ┃ ┣ index.ts\n  ┃ ┗ withApi.tsx\n  ┣ ...\nUnder /front/mocks/Api there is a list of folders named by mocked services.\nIn the index.ts file of each folder there is an export structure like this one::::{code-block} typescript\nexport const ResidentApi = {\n['GET:/resident']: rest.get(*/resident, (req, res, ctx) => {\nreturn res(ctx.json({\npropertyCode: '123456789',\npropertyAddress: '5555 Mahogany Run Pl, Las Vegas NV, 12345',\nisActive: true,\n}));\n}),\n['PROPERTY=>GET:/resident']: (property: TResidentProperty) => rest.get(*/resident, (req, res, ctx) => {\nreturn res(ctx.json(property));\n})\n};\n:::Check the structure and go to step 4 if all the requests you need are already listed.","3-prepare-new-mocked-data-for-api-request#3. Prepare new mocked data for api request":"If you need to add a new data set for a request that has not yet been mocked:\nCreate a new one mock function\nExport it in the structure like export const ResidentApi, respecting the existing folder and file structure.\n:::{note}\nNot only objects type of RestHandler can be provided as mock objects to match the request url, as for the 'GET:*/resident' request in the example above, but also functions like (context: StoryContext) => RestHandler.\nThis may be necessary to generate dynamic rest responses based on story arguments.\n:::","4-use-withapi-decorator-in-storybook#4. Use withApi decorator in storybook":"Now it is simply enough to add a decorator to intercept the needed requests and return the test data prepared in the previous steps.:::{code-block} typescript\n:linenos:import { withApi, ApiMock } from '@mocks';\nconst propertyMock = getStoreMock().property?.property;export default {\ndecorators: [\nwithApi([(context) => ApiMock'PROPERTY=>GET:*/resident']),\n],\n} as Meta;export const Default: Meta = {\nargs: { ...propertyMock },\ndecorators: [withApi([\n(context) => ApiMock['GET:/Scheduler/property/:propertyCode/ticket/:ticketId/timeslots'](context.args.propertyCode, ticketId),\n(context) => ApiMock'GET:*/facilgo/property/:propertyCode/workorder/history',\nApiMock['GET:/ticket/lastnotscheduled'],\nApiMock['GET:/Issue/readSkipMarkets'],\nApiMock['GET:/resident'],\n])],\n};\n::::::{note}\nDecorator declared on line 6 will be applied to all the stories in the file, and the others will be applied only to the specific story within which they are declared.\n:::","state-mocks#State mocks":"Consider the structure of helper files used to create the state mocks.\nfront/\n┗ mocks/\n  ┣ Api/\n  ┃ ...\n  ┣ Store/\n  ┃ ┣ index.ts\n  ┃ ┣ store.mock.ts\n  ┃ ┣ utils.tsx\n  ┃ ┣ withAuthState.tsx\n  ┃ ┗ withPropertyState.tsx\n...","global-state-mock#Global state mock":"The store.mock.ts file contains default data for every story in project. It is done with the help of the following global state decorator declared in utils.tsx and applied in .storybook/global.config.js :::{dropdown} Global state mock decorator\n:::{code-block} jsx\n:linenos:export function storeDecorator(Story: Story, context: TStorybookContext, stateModifiers?: TStoreStateModifier[], currentState?: TStoreState) {\nlet store: TStore;\nif (!stateModifiers?.length) store = createTestStore(getStoreMock());\nelse {\nconst state = currentState || getStoreMock();\n    stateModifiers.forEach((modifier) => {\n        modifier(state, context);\n    });\n    store = createTestStore(state);\n}\nreturn (\n    <StoreProvider store={store}>\n        <Story />\n    </StoreProvider>\n);\n}\n::::::{note}\nAs with the API decorator, the global state decorator is used for static default values for each story in the project. If you need to override these values or make them dependent on story arguments, use the story-specific decorators described below.\n:::","story-specific-state-mocks#Story-specific state mocks":"In case of the need to change store state for the specific story, you can use withStore decorator placed in front/mocks/Store/utils:::{code-block} jsx\n:linenos:\n:caption: \"Implementation of the story-specific redux-like store state decorator\"\nexport function withStore(stateModifiers?: TStoreStateModifier[]) {\nreturn (story: Story, context: TStorybookContext) => {\nconst state = useStoreState((state: TStoreState) => state);\nreturn storeDecorator(story, context, stateModifiers, state);\n};\n}\n::::::{code-block} jsx\n:linenos:\n:caption: \"Usage of the state decorator on the storybook level i.e. for every story in file\"\nexport default {\ndecorators: [\nwithStore([withPropertyState((context) => context.args as TResidentProperty)]),\n],\n} as Meta;\n::::::{code-block} jsx\n:linenos:\n:caption: \"Usage of the state decorator on the specific story level\"\nexport const Agent: Meta = {\ndecorators: [withStore([withAuthState({ role: TUserRole.AGENT })])],\n};\n:::TStoreStateModifier - the type of array arguments of withStore([...]) represents a function of type (state: TStoreState, context: TStorybookContext) => void which means the implementation should mutate state passed as argument.There is also a context type argument, which can be useful if you need to dynamically change state based on story arguments.Below are the options for implementing state modifiers that use context or static props.:::{dropdown} State mock decorator based on static override\n:::{code-block} typescript\n:caption: \"Implementation of a state decorator which have a property of a type TUser & TResidentAuth to override corresponding fields in state\"\n:linenos:import { PartialDeep } from 'type-fest/source/partial-deep';\nimport { TResidentAuth, TStoreStateModifier, TUser } from '@types';export function withAuthState({ role, email, isReadonly }: PartialDeep<TUser & TResidentAuth>): TStoreStateModifier {\nreturn (storeState) => {\nconst userEmail = email ?? storeState.authentication?.user?.email;\nstoreState.authentication = {\n...storeState.authentication,\nuser: {\n...storeState.authentication!.user,\nemail: userEmail,\nrole,\n},\nresident: {\nemail: userEmail,\nisReadonly,\n},\n};\n};\n}\n::::::{dropdown} Dynamic state mock decorator based on story context\n:::{code-block} jsx\n:caption: \"Implementation of a state decorator which can use both static TResidentProperty property and a factory of TResidentProperty based on story context\"\n:linenos:import { TResidentProperty, TStoreStateModifier, TStorybookContext } from '@types';export function withPropertyState(property: TResidentProperty | TResidentPropertyFactory): TStoreStateModifier {\nreturn (storeState, context) => {\nif (property instanceof Function) {\nconst newPropertyState = { property: property(context) };\nstoreState.property = { ...storeState.property, ...{ ...newPropertyState } };\n} else {\nstoreState.property = { ...storeState.property, ...{ property } };\n}\n};\n}type TResidentPropertyFactory = (context: TStorybookContext) => TResidentProperty;\n::::::{note}\nLower-level state decorators do not cancel more global decorators. So you can define a storybook-level state mock for all the stories in a file, and then, for individual stories, augment the effect of that mock by declaring story-specific withStore decorator.\n:::","router-mocks#Router mocks":"Some components rely on getting data from the current URL route. To mock this data, react-router library provides a MemoryRouter component that keeps the history of \"URL\" in memory (does not read or write to the address bar).Within the storybook we can also use the decorator (located in front/mocks/router.mock.tsx) to substitute the real router with the pre-configured MemoryRouter.:::{dropdown} Implementation of the withRoutes decorator using MemoryRouter\n:::{code-block} jsx\n:linenos:import { MemoryRouter, Routes, Route } from 'react-router-dom';type TLocationMock = string | ((storyContext: StoryContext) => string);const defaultRoutes = ['/summary/:ticketId/scheduler'];\nexport const withRoutes = (historyStack: TLocationMock[] = [], routes: string[] = defaultRoutes) => {\nreturn (Story: Story, storyContext: TStorybookContext) => (\n<MemoryRouter\ninitialEntries={historyStack.map((location) => {\nif (typeof location === 'string') {\nreturn location;\n}\nreturn location(storyContext);\n})}\n>\n{routes.map((route: string, index: number) => (\n<Route key={index} path={route} element={} />\n))}\n);\n};\n::::::{code-block} jsx\n:linenos:\n:caption: \"Usage of the withRoutes decorator on the storybook level i.e. for every story in file\"\nexport default {\ntitle: 'Pages/SchedulerPage',\ncomponent: SchedulerPage,\ndecorators: [\nwithRoutes(['/summary/123/scheduler', '/summary/path-override/:ticketId/scheduler']),\n]\n} as Meta;\n::::::{note}\nMemoryRouter needs a route configuration and an actual location stack. Since the route configuration is stable throughout the application, it is worth declaring it once within the withRoutes implementation in the defaultRoutes array. If necessary, you can still override the route configuration by passing routes array as the second parameter of the decorator at it is displayed in the example above.\n:::You can also configure withRoutes decorator passing dynamic paths based on story arguments.:::{code-block} jsx\n:linenos:\n:caption: \"Usage of the state decorator on the specific story level\"\nexport const NotesWithCollectedItems: Meta = {\nargs: { propertyId },\ndecorators: [withRoutes([(context) => `/properties/${context.args.propertyId}'])],\n};\n:::","component-mocks#Component mocks":"Sometimes, for example when creating a story for an entire application page, it is necessary to replace some components that are not ready for tests with stubs.In such cases the technique of substitution of imported components during webpack building can be useful.\nFor this purpose, `jest.config.js` has parameters `globalSetup` and `setupFilesAfterEnv`, which define the configuration files that will be connected during the build phase and during the execution of each test, respectively.\nBased on these files, you can set up the substitution of imported modules with any other by name pattern.\n:::{code-block} jsx\n    :linenos:\n    :caption: \"Implementation of searching and replacement of the components to be mocked in the `globalSetup` file\" \nconst path = require('path');\nconst glob = require('glob');\nmodule.exports = async () => {\n    const mocksSetups = [];\n    const frontDirPath = path.resolve(__dirname, '../../front/');\n    const srcDirPath = path.resolve(__dirname, '../../front/src/');\n    const mocks = glob.sync(`${frontDirPath}/**/*.mock.tsx`);\n    if (!mocks || !mocks.length) return;\n    console.log('FOUND SOME MOCKS');\n    mocks.forEach((mock) => {\n        const resourceMockName = path.basename(mock);\n        const resourceName = resourceMockName.replace('.mock', '');\n        console.log('TRYING TO FIND MOCKED RESOURCE', `${srcDirPath}/**/${resourceName}`);\n        const resources = glob.sync(`${srcDirPath}/**/${resourceName}`);\n        if (!resources || !resources.length) return;\n        console.log('FOUND RESOURCE TO MOCK GLOBALLY', resources[0]);\n        mocksSetups.push({ resource: resources[0], mock });\n    });\n    process.env = Object.assign(process.env, { MOCKS: JSON.stringify(mocksSetups) });\n};\n:::\n:::{code-block} jsx\n    :linenos:\n    :caption: \"Implementation of loading of mocked components before test execution in the `setupFilesAfterEnv` file\" \nimport '@testing-library/jest-dom/extend-expect';\nimport 'whatwg-fetch';\nimport { configure } from '@testing-library/react';\nconfigure({ testIdAttribute: 'data-testid' });\nfunction setupMocks() {\n    const mocksSetups = process.env.MOCKS ? JSON.parse(process.env.MOCKS) : [];\n    if (!mocksSetups || !mocksSetups.length) return;\n    mocksSetups.forEach((mockSetup) => {\n        jest.doMock(mockSetup.resource, () => jest.requireActual(mockSetup.mock));\n    });\n}\nsetupMocks();\n:::\nTo use this technique, the implementation of which is presented above, it is sufficient to create a file component.mock.tsx next to the component.tsx file from which the component is imported.\nfront/\n┗ @components/\n  ┣ MyComponent/\n  ┃ ┣ index.tsx\n  ┃ ┗ MyComponent.mock.tsx\n  ┣ MyComponent2.tsx\n  ┣ MyComponent2.mock.tsx\n...\nIf there is such a mock file for a component, the storybook and tests will use the mock instead of the component."}},"/front-end/testing/snapshots":{"title":"Snapshot testing","data":{"":"A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.:::{seealso}\nLearn more about snapshot testing in the perfect jest snapshot documentation\n::::::{note}\nSnapshots are an ideal way to quickly provide basic test coverage of a component. The more component stories you cover with snapshots, the less you need to write integration tests with Jest\n:::We will use two types of a snapshot test cases: automatically created by storybook and manual.Lets describe the typical flow of a snapshot testing.","1-set-up-automatically-created-snapshots#1. Set up automatically created snapshots":"Since the storybook is a base of all our UI tests, lets use it addon storyshots to automatically create a snapshot.\n:::{code-block} jsx\n    :linenos:\n    :caption: Setup of a storyshots addon which allows to test asynchronously loaded components\nimport React from 'react';\nimport { act } from 'react-dom/test-utils';\nimport initStoryshots, { Stories2SnapsConverter } from '@storybook/addon-storyshots';\nimport wait from 'waait';\nimport { composeStory } from '@storybook/testing-react';\nimport { render } from '@testing-library/react';\ninitStoryshots({\n    asyncJest: true,\n    test: async ({ story, context, done }) => {\n        try {\n            const converter = new Stories2SnapsConverter({\n                snapshotsDirName: './',\n                snapshotExtension: '.snapshot',\n            });\n            const snapshotFilename = converter.getSnapshotFileName(context);\n            story.story = undefined;\n            let tree: any;\n            await act(async () => {\n                const meta = await import(`${story.fileName}`);\n                const Story = composeStory(story, meta);\n                tree = render(<Story />);\n            });\n            await act(() => wait(100));\n            expect(tree?.baseElement).toMatchSpecificSnapshot(snapshotFilename);\n        } catch (e) {\n            console.log('ERROR TESTING SNAPSHOT', e);\n        } finally {\n            done?.();\n        }\n    },\n});\n:::\nAutomatically created snapshot files will be placed in the same folder as a component and named based on the storybook\n:::{code-block}\n:emphasize-lines: 7\nfront/\n┗ @components/\n┣ EmployeeProfile/\n┃ ┣ index.ts\n┃ ┣ employee-profile.tsx\n┃ ┣ employee-profile.stories.tsx\n┃ ┗ employee-profile.stories.tsx.snap\n┣ ...\n::::::{note}\nFor a complex storybook the automatically created snapshot could fail with a timeout or became corrupted. To work around this check the instructions below.\n:::","2-check-automatically-created-snapshot#2. Check automatically created snapshot":"To quickly check if automatic snapshot is ok, run tests specifying snapshots config only:::{code-block} console\nyarn test snapshots.spec.tsx\n:::If tests are ok, check the snapshot file created in the component's folder. If your story contains some async data loading check that snapshot contains that data.If test fails or a snapshot does not contain mocked data, proceed to the next step.","3-disabling-automatic-creation-of-the-story-snapshot#3. Disabling automatic creation of the story snapshot":"In case you are not satisfied with the results of the automatic snapshot creation you can disable it.\nTo do this, add a special parameter to the story:::{code-block} typescript\n:caption: The story with disabled automatic snapshots\n:linenos:export const Admin: Meta = {\n// ...\nparameters = {\nstoryshots: { disable: true },\n};\n};\n::::::{important}\nBe sure to disable automatic snapshots if you use the play function to interact with the component\n:::","4-manual-creating-of-a-snapshots-with-jest#4. Manual creating of a snapshots with jest":"To configure manual snapshot you should create a file for a common jest tests like this:::{code-block}\n:emphasize-lines: 7\nfront/\n┗ @components/\n┣ EmployeeProfile/\n┃ ┣ index.ts\n┃ ┣ employee-profile.tsx\n┃ ┣ employee-profile.stories.tsx\n┃ ┗ employee-profile.spec.tsx\n┣ ...\n:::Suppose we have a story that requires special interaction before a snapshot can be taken. In this case, manual snapshots come to the rescue.\nWe can add a new jest based test which will create a manual snapshot for us.:::{code-block} typescript\n:caption: The manually created snapshot test with custom logic\n:linenos:\nimport * as stories from './employee-profile.stories';\nconst { Admin } = composeStories(stories);describe('Should match snapshot', () => {\ntest('with edit modal opened', async () => {\nconst { container, baseElement } = render();\nawait act(() => Admin.play({ canvasElement: container }));\n    await screen.findByText('Edit modal title');\n    expect(baseElement).toMatchSnapshot(Admin.storyName);\n});\n});\n:::","5-snapshot-tests-maintenance#5. Snapshot tests maintenance":"It makes no sense to duplicate the perfect jest snapshot documentationLet's list only the main points about snapshot maintenance:\nTreat snapshots as code - commit & review snapshots\nSnapshots should be deterministic - mock any kind of data that can be changed e.x. new Date()\nUpdate snapshots after changing components\nTo update snapshots manually with interactive snapshot mode run the command\n:::{code-block} console\nyarn test snapshots.spec.tsx --watch\n:::\nCheck your snapshots are ok before creating a PR"}},"/front-end/testing/stories":{"title":"Writing stories","data":{"":"Story - is a part of storybook file describing some behavior of testable component.\nThink of a storybook like of a components and stories like this component's modes.\nLets describe it on an example.","creating-a-storybook#Creating a storybook":"As the story is a part of storybook lets create it first.\nAs you already aware storybook is a .tsx file written in CSF 3.0 storybook format.Assume that we want to create a component for viewing employee profile.\nThis displays an employee data taken from REST API by id from the URL\nShows loading indicator while profile data is fetching from the UI\nIf authenticated user role is administrator, the component shows an 'Edit' button opening profile data editing modal window\nSo, lets create a storybook file.\n:::{code-block}\n:emphasize-lines: 6\nfront/\n┗ @components/\n┣ EmployeeProfile/\n┃ ┣ index.ts\n┃ ┣ employee-profile.tsx\n┃ ┗ employee-profile.stories.tsx\n┣ ...\n::::::{seealso}\nLearn more about folder structure best practices\n::::::{code-block} typescript\n:caption: The contents of the employee-profile.stories.tsx\n:linenos:import { EmployeeProfile } from './';export default {\ntitle: 'Components/EmployeeProfile',\ncomponent: EmployeeProfile,\ndecorators: [\nwithRoutes(['/employee/123/scheduler', '/employee/:employeeId']),\nwithApi([ApiMock['api/employee/:employeeId']]),\nwithStore([withStore([withAuthState({ role: TUserRole.USER })])]),\n],\n} as Meta;export const Default: Meta = {};\n:::This is the minimum set up of our story. Check storybook chapter for the deep explanation of the file's structure.Now the most interesting line for us is 13: export const Default: Meta = {};\nIt is default story. It is mandatory to have at least on named export from a storybook file for a default component view.At this step we already have our EmployeeProfile component displayed in the storybook and we can continue it's development right there - inside a sandbox without need of a backend.But lets write a few more meaningful stories to cover base functionality of the component.","adding-a-story-with-rest-api-mock-override#Adding a story with Rest API mock override":"Assuming that we have this kind of api mock setup\n:::{code-block} typescript\n:caption: Rest api mock returning an employee profile data or waiting forever based on parameter\nexport const ResidentApi = {\n['api/employee/:employeeId']: ({ isLoading }) => rest.get(api/employee/:employeeId, (req, res, ctx) => {\nreturn isLoading ? res(ctx.delay('infinite'))) : res(ctx.json({\nname: 'John Smith',\nposition: 'Senior Web Developer',\ndepartment: 'R&D'\n}));\n})\n};\n:::Lets write a story to check if our component displays the loading indicator properly:::{code-block} typescript\n:caption: The story overrides the default api mock\n:linenos:export const Loading: Meta = {\ndecorators: [\nwithApi([() => ApiMock['api/employee/:employeeId']({ isLoading: true })]),\n],\n};\n:::That simple! We only need to cover parameters that differs from the default configuration.","adding-a-story-with-component-interaction#Adding a story with component interaction":"Lets create a story for displaying employee's profile data for the administrator with possibility to open profile data editing modal by pressing a button 'Edit':::{code-block} typescript\n:caption: The story for the user 'admin'. Changing the redux state storing the user's role and implementing play function for component interaction\n:linenos:export const Admin: Meta = {\ndecorators: [\nwithStore([withStore([withAuthState({ role: TUserRole.ADMIN })])]),\n],\nplay: ({ canvasElement }: { canvasElement: HTMLElement }) => {\nconst canvas = within(canvasElement);\nconst editButton = await canvas.findByText('Edit');\nawait userEvent.click(editButton);\n}\n};\n:::Now opening the storybook and navigating to the Components/EmployeeProfile folder we should have these three stories:\nThe Default one. Displaying employee's profile data for user authenticated with role TUserRole.USER\nLoading. Displaying infinite animated loading indicator\nAdmin. Displaying and clicking 'Edit' button in addition to the employee's profile for user authenticated with role TUserRole.ADMIN\nThis is the very basic functional of the stories. But it is enough for developing and testing purposes.:::{seealso}\nTo check more please visit official docs page\n:::"}},"/front-end/testing/storybook":{"title":"Storybook","data":{"":"Storybook is a tool for UI development. It makes development faster and easier by isolating components.We will use storybook as the base for our UI tests.\nYou can read more about storybook on official site","the-idea#The idea":"Storybook is a sandbox where any UI component can be created separately without any backend resources with all dependencies mocked.At the heart of a Storybook lies the idea of building an application's design-system based on the conception of the component driven design. Starting with smallest components, composing them up to fully functional application pages.","file-structure#File structure":"For a single component, the Storybook is a file component-name.stories.tsx placed in the component's folder.The structure of the file itself is created according to the rules of Component Story Format (CSF) 3.0Let's look at an example of a typical storybook:::{code-block} typescript\n:linenos:export default {\ntitle: 'Components/PropertyInformation',\ncomponent: PropertyInformation,\ndecorators: [\nwithApi([(context) => ApiMock'PROPERTY=>GET:*/resident']),\nwithStore([withPropertyState((context) => context.args as TResidentProperty)]),\n],\n} as Meta;export const Default: Meta = {\nargs: { ...propertyMock },\ndecorators: [withStore([withAuthState({ role: TUserRole.AGENT })])],\n};\n:::These are parts that every storybook file should have:\n{guilabel}line 1 Default export\n{guilabel}line 2 Title bar, which is split by / to create subfolders in components tree\n{guilabel}line 3 The component that needs to be mapped. Can be a test wrapper around a real component\n{guilabel}line 8 {code}as Meta - is needed for typescript to export stories properly\n{guilabel}line 10 {code}export const ComponentName: Meta - a story definition. Should have at least one.\nOptional attributes include:\n{guilabel}line 4-7 Common decorators for all stories\n{guilabel}line 12 Decorators for specific story\n{guilabel}line 12 Arguments of a story that will be passed to component and will be controllable via storybook controls","storybook-arguments#Storybook arguments":"Arguments can be used to dynamically change props, slots, styles, inputs, etc. It allows Storybook and its addons to live edit components.To read more about arguments see this documentation","storybook-decorators#Storybook decorators":"When writing stories, decorators are typically used to wrap stories with extra markup or context mocking.Decorator is a function of the form\n:::{code-block} jsx\n(Story: Story, storyContext: StoryContext) => \n:::AnyWrapperComponent can be a provider of any context or an arbitrary component.However, it is assumed that the decorator does not affect the rendering of the story. To make changes to the DOM of a particular story, the render function must be declared explicitly see CSF3 definition.Decorators can be declared at three levels:\nAt the configuration level, in global.config.js (by default in preview.js). Such decorators will be applied to all stories.\nAt the storybook level.\n:::{code-block} typescript\n:caption: \"Rest API & Redux store mock decorators declared at the storybook level\"\n:emphasize-lines: 2\nexport default {\ndecorators: [\nwithApi([(context) => ApiMock'PROPERTY=>GET:*/resident']),\nwithStore([withPropertyState((context) => context.args as TResidentProperty)]),\n],\n} as Meta;\n:::\nAt the story level\n:::{code-block} typescript\n:caption: \"Redux store mock decorator declared at the story level\"\n:emphasize-lines: 3\nexport const Default: Meta = {\nargs: { ...propertyMock },\ndecorators: [withStore([withAuthState({ role: TUserRole.AGENT })])],\n};\n:::\nAt the story level, decorators of all levels will merge their behavior, unless they are specifically configured to override parent's level behavior.You can read more about decorators in the documentationWe will also take a closer look at the use of specific decorators in mocks section.","running-a-storybook#Running a storybook":"Storybook is a typical static web-application built & run via webpack.\nStorybook's special webpack.config.js is placed under .storybook/webpack.config.jsTo start storybook locally run the script\nyarn storybook"}}}